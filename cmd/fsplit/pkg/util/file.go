package util

import (
	"io"
	"io/ioutil"
	"log"
	"math"
	"os"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
)

const (
	// SplitSeparator is used to generate chunk files
	SplitSeparator = ".part@"

	// MaxRW is max size one read/write can handle
	MaxRW = 1 << 30

	// DefaultBufferSize is default read/write buffer size
	DefaultBufferSize = 1024 * 1024 * 8 // 8M bytes
)

func ExcludeExt(filename string) string {
	var extension = filepath.Ext(filename)
	return filename[0 : len(filename)-len(extension)]
}

// FinalName returns the joined file name.
// For file name generated by split command, FinalName returns the
// unmodified part, e.g. `xx.mkv.part@1` -> `xx.mkv`
func FinalName(filename string) string {
	var finalName string

	// NOTE: check whether the file is generated by split command
	ss := strings.Split(filename, SplitSeparator)
	if len(ss) > 1 {
		return strings.Join(ss[:len(ss)-1], SplitSeparator)
	}

	ext := filepath.Ext(filename)
	name := ExcludeExt(filename)

	finalName = name + "_all"
	if len(ext) > 0 {
		return finalName + ext
	}

	return filename
}

// ChunkFileName uses .part@[index] as suffix
func ChunkFileName(filename string, index uint64) string {
	return filename + SplitSeparator + strconv.FormatUint(index, 10)
}

func SplitFile(filename string, chunkNum int) error {
	// NOTE: use absolute path
	abs, err := filepath.Abs(filename)
	if err != nil {
		return err
	}

	file, err := os.Open(abs)
	if err != nil {
		return err
	}
	defer file.Close()

	fileInfo, _ := file.Stat()
	var fileSize int64 = fileInfo.Size()
	chunkSize := int64(math.Ceil(float64(fileSize) / float64(chunkNum)))

	for i := uint64(0); i < uint64(chunkNum); i++ {

		fileName := ChunkFileName(abs, i+1)
		f, err := os.Create(fileName)

		if err != nil {
			return err
		}

		err = AppendFile(f, file, chunkSize)
		f.Close()

		if err != nil {
			return err
		}

		//	partBuffer := make([]byte, chunkSize)
		// write/save buffer to disk
		// err = ioutil.WriteFile(fileName, partBuffer[:n], os.ModeAppend)
		log.Println("Split to : ", fileName)
	}

	return nil
}

// AppendFile with limit
func AppendFile(dst *os.File, src *os.File, limit int64) error {
	var bufSize = int(limit)
	if bufSize >= MaxRW {
		bufSize = MaxRW
	}

	// NOTE: reuse buffer
	buf := make([]byte, bufSize)

	var left = limit
	for left > 0 {
		if left < int64(bufSize) {
			buf = make([]byte, left)
		}

		n, err := src.Read(buf)
		if err == io.EOF {
			return nil
		}

		if err != nil {
			return err
		}

		_, _ = dst.Write(buf[:n])
		_ = dst.Sync()

		left -= int64(n)
	}

	return nil
}

// FindFiles gets file list matched given pattern in absoluate path
func FindFiles(dir string, pattern string) ([]string, error) {
	re, err := regexp.Compile(".*" + pattern + ".*")
	if err != nil {
		return nil, err
	}

	// TODO
	// use filepath.Walk methods to handle
	// lots of files in the directory

	var result []string
	files, err := ioutil.ReadDir(dir)
	for _, f := range files {
		if f.IsDir() {
			continue
		}

		name := f.Name()
		if re.MatchString(name) {
			result = append(result, filepath.Join(dir, name))
		}
	}

	return result, nil
}
